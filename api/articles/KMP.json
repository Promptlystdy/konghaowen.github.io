{"title":"KMP算法","uid":"ed698b80a4ed647896206c94dc889942","slug":"KMP","date":"2021-01-08T11:24:37.000Z","updated":"2021-09-01T16:26:48.512Z","comments":true,"path":"api/articles/KMP.json","keywords":null,"cover":[],"content":"<h2 id=\"KMP简介\"><a href=\"#KMP简介\" class=\"headerlink\" title=\"KMP简介\"></a>KMP简介</h2><p>KMP算法是我们数据结构串中最难也是最重要的算法。难是因为KMP算法的代码很优美简洁干练，但里面包含着非常深的思维。真正理解代码的人可以说对KMP算法的了解已经相当深入了。而且这个算法的不少东西的确不容易讲懂，很多正规的书本把概念一摆出直接劝退无数人。这篇文章将尽量以最详细的方式配图介绍KMP算法及其改进。文章的开始我先对KMP算法的三位创始人Knuth,Morris,Pratt致敬，懂得这个算法的流程后你真的不得不佩服他们的聪明才智。</p>\n<h2 id=\"KMP解决的问题\"><a href=\"#KMP解决的问题\" class=\"headerlink\" title=\"KMP解决的问题\"></a>KMP解决的问题</h2><p>KMP算法的作用是在一个已知字符串中查找子串的位置,也叫做串的模式匹配。比如主串s=“goodgoogle”,子串t=“google”。现在我们要找到子串t 在主串s 中的位置。大家肯定觉得这还不简单，不就在第五个嘛，一眼就看出来了。<br>当然，在字符串非常少时，“肉眼观察法”不失为一个好方法。但如果要你在一千行文本里找一个单词，我想一般人都会数得崩溃吧。这就让我想起来考试的时候，如果一两道选择题不会。这时候，“肉眼观察法”可能效果不错，但是如果好几道大题不会呢？“肉眼观察法”就丝毫不起效了。所以打铁还需自身硬，我们把这种枯燥的事以一定的算法交给计算机处理。<br>第一种我们容易想到的就是暴力求解法。<br>这种方法也叫朴素的模式匹配：</p>\n<p>简单来说就是：从主串s 和子串t 的第一个字符开始，将两字符串的字符一一比对，如果出现某个字符不匹配，主串回溯到第二个字符，子串回溯到第一个字符再进行一一比对。如果出现某个字符不匹配，主串回溯到第三个字符，子串回溯到第一个字符再进行一一比对…一直到子串字符全部匹配成功。</p>\n<p>下面我们通过图片展示这个过程：<br>竖直线表示相等，闪电线表示不等<br>第一个过程：子串“goo”部分与主串相等，’g’不等，结束比对，进行回溯。<br><img src=\"picture/1.jpg\" alt=\"1-1\"></p>\n","text":"KMP简介KMP算法是我们数据结构串中最难也是最重要的算法。难是因为KMP算法的代码很优美简洁干练，但里面包含着非常深的思维。真正理解代码的人可以说对KMP算法的了解已经相当深入了。而且这个算法的不少东西的确不容易讲懂，很多正规的书本把概念一摆出直接劝退无数人。这篇文章将尽量以最...","link":"","photos":[],"count_time":{"symbolsCount":750,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构复习","slug":"数据结构复习","count":1,"path":"api/tags/数据结构复习.json"},{"name":"串","slug":"串","count":1,"path":"api/tags/串.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KMP%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">KMP简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KMP%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">KMP解决的问题</span></a></li></ol>","author":{"name":"追了又追","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/konghaowen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"关键字：enum","uid":"385337453c0362e2e26547a4a0f5d697","slug":"enum","date":"2021-05-31T02:39:00.000Z","updated":"2021-09-01T16:33:15.668Z","comments":true,"path":"api/articles/enum.json","keywords":null,"cover":null,"text":"枚举类的属性：1.枚举类不应允许被改动，用private final修饰 2.使用的时候应该在构造器里赋值 3.定义带参的构造器，则在列出枚举值时也必须对应的传入参数。 代码： class Season&#123; &#x2F;&#x2F;1.声明Season对象的属性:priv...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"追了又追","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/konghaowen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}}},"next_post":{}}