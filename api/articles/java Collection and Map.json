{"title":"Java 集合","uid":"34c2acd56bc16b503002a852a65f4137","slug":"java Collection and Map","date":"2021-05-31T02:39:00.000Z","updated":"2021-09-01T16:26:32.060Z","comments":true,"path":"api/articles/java Collection and Map.json","keywords":null,"cover":null,"content":"<p>JSON：一种轻量的数据交换格式。</p>\n<h2 id=\"集合分为-Collection-和-Map-两种体系\"><a href=\"#集合分为-Collection-和-Map-两种体系\" class=\"headerlink\" title=\"集合分为 Collection 和 Map 两种体系\"></a>集合分为 Collection 和 Map 两种体系</h2><h2 id=\"1-collection接口：\"><a href=\"#1-collection接口：\" class=\"headerlink\" title=\"1.collection接口：\"></a>1.collection接口：</h2><p>单列数据，定义存取一组对象的方法的集合</p>\n<p>List：元素有序，可以重复的集合</p>\n<p>Set：元素无序，不可以重复的集合</p>\n<p>Collection接口是List，Set，Queue接口的父接口。</p>\n<p>接口的方法：</p>\n<ul>\n<li>add(Object obj); 添加元素</li>\n<li>addAll(Collection coll); 添加一个Collection类型的集合</li>\n<li>int size(); 获取有效元素的个数</li>\n<li>void clear(); 清空集合</li>\n<li>boolean isEmpty();是否为空集合</li>\n<li>boolean contains(Object obj); 通过调用元素所在类的equals()方法来判断是否是同一个对象。</li>\n<li>boolean containsAll(Collection c); 调用元素所在类的equals()方法来比较，用两个集合元素依次比较。</li>\n<li>boolean remove(Object obj); 通过元素的equals()方法判断是否是要删除的元素，只会删除找到的第一个元素。</li>\n<li>boolean removeAll(Collection coll); 取当前集合的差集</li>\n<li>boolean retainAll(Collection c); 把交集的结果存在当前集合中，不影响 c</li>\n<li>boolean equals(Object obj); 判断集合是否相等</li>\n<li>Object[] toArray(); 转成对象数组</li>\n<li>hashCode(); 获取集合对象的哈希值</li>\n<li>iterator(); 返回迭代器对象，用于集合遍历</li>\n</ul>\n<h2 id=\"2-Map接口：\"><a href=\"#2-Map接口：\" class=\"headerlink\" title=\"2.Map接口：\"></a>2.Map接口：</h2><p>双列数据，保存具有映射关系“key-value对”的集合。</p>\n<p><strong>Iterator迭代器接口</strong></p>\n<p><strong>使用 Iterator 接口遍历集合元素</strong></p>\n<p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</p>\n<p>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元 素，而又不需暴露该对象的内部细节。<strong>迭代器模式，就是为容器而生。</strong>类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。</p>\n<p>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所 有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了 Iterator接口的对象。</p>\n<p>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。</p>\n<p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</p>\n<p>在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且 下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</p>\n<p><em>Iterator和ListIterator的异同点</em></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">一．相同点\n都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。\n二．不同点\n1.使用范围不同，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而ListIterator只能用于List及其子类型。\n2.ListIterator有add方法，可以向List中添加对象，而Iterator不能。\n3.ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator不可以。\n4.ListIterator可以定位当前索引的位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。\n5.都可实现删除操作，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。</code></pre>","text":"JSON：一种轻量的数据交换格式。 集合分为 Collection 和 Map 两种体系1.collection接口：单列数据，定义存取一组对象的方法的集合 List：元素有序，可以重复的集合 Set：元素无序，不可以重复的集合 Collection接口是List，Set，Que...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Java SE","slug":"Java-SE","count":2,"path":"api/categories/Java-SE.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E5%88%86%E4%B8%BA-Collection-%E5%92%8C-Map-%E4%B8%A4%E7%A7%8D%E4%BD%93%E7%B3%BB\"><span class=\"toc-text\">集合分为 Collection 和 Map 两种体系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-collection%E6%8E%A5%E5%8F%A3%EF%BC%9A\"><span class=\"toc-text\">1.collection接口：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-Map%E6%8E%A5%E5%8F%A3%EF%BC%9A\"><span class=\"toc-text\">2.Map接口：</span></a></li></ol>","author":{"name":"追了又追","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/konghaowen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"关键字：enum","uid":"385337453c0362e2e26547a4a0f5d697","slug":"enum","date":"2021-05-31T02:39:00.000Z","updated":"2021-09-01T16:33:15.668Z","comments":true,"path":"api/articles/enum.json","keywords":null,"cover":null,"text":"枚举类的属性：1.枚举类不应允许被改动，用private final修饰 2.使用的时候应该在构造器里赋值 3.定义带参的构造器，则在列出枚举值时也必须对应的传入参数。 代码： class Season&#123; &#x2F;&#x2F;1.声明Season对象的属性:priv...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"追了又追","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/konghaowen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}}},"next_post":{"title":"Docker_1","uid":"39fbe56f95ea6b657e8f83c1879e3a6a","slug":"Docker_1","date":"2021-01-08T11:24:37.000Z","updated":"2021-09-01T16:25:35.949Z","comments":true,"path":"api/articles/Docker_1.json","keywords":null,"cover":null,"text":"Docker是什么？麻烦的环境部署在软件开发中，最麻烦的事情之一就是环境配置。在正常情况下，如果要保证程序能运行，我们需要设置好操作系统，以及各种库和组件的安装。 举例来说，要运行一个Python程序，计算机必须要有 Python 引擎，还需要安装好程序的各种依赖，甚至还要配置特...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"Docker","slug":"Docker","count":1,"path":"api/categories/Docker.json"}],"tags":[{"name":"配置","slug":"配置","count":1,"path":"api/tags/配置.json"},{"name":"docker学习","slug":"docker学习","count":1,"path":"api/tags/docker学习.json"}],"author":{"name":"追了又追","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/konghaowen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}}}}