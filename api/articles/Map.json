{"title":"MAP","uid":"9996538c634b4fe0a9727deaea0413da","slug":"Map","date":"2021-05-31T02:39:00.000Z","updated":"2021-09-01T16:27:05.535Z","comments":true,"path":"api/articles/Map.json","keywords":null,"cover":[],"content":"<h2 id=\"1-Map接口概述：\"><a href=\"#1-Map接口概述：\" class=\"headerlink\" title=\"1.Map接口概述：\"></a>1.<strong>Map接口概述</strong>：</h2><ul>\n<li>Map与Collection并列存在，用于保存具有<strong>映射关系</strong>的数据：key-value</li>\n<li>Map中的key和value都可以是任何引用类型的数据。</li>\n<li>Map中的key用Set来存放，不允许重复，即同一个Map对象所对应的类，须重写hashCode()和equlas() 方法，</li>\n<li>常用String类作为Map的 “键” (key)</li>\n<li>key和value之间存在单向一对一的关系，即通过指定的key总能找到唯一的、确定的value</li>\n<li>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，<strong>HashMap</strong>是Map接口使用频率最高的实现类</li>\n</ul>\n<h2 id=\"2-Map实现类结构\"><a href=\"#2-Map实现类结构\" class=\"headerlink\" title=\"2.Map实现类结构\"></a>2.Map实现类结构</h2><ul>\n<li><p>Map</p>\n<p>：存储双列数据，存储key-value对的数据，类似函数的概念</p>\n<ul>\n<li><p>HashMap</p>\n<p>：作为Map的主要实现类：线程不安全，效率高，可以存储null的key和value</p>\n<ul>\n<li><strong>LinkedHashMap</strong>：能保证在遍历map元素时，可以按照添加的顺序进行遍历。实现方法是在原有的HashMap底层结构的基础上添加了一对指针，指向前一个和后一个元素。对于频繁遍历的操作，此类执行效率高于HashMap。</li>\n</ul>\n</li>\n<li><p><strong>TreeMap</strong>：（有序）保证按照添加的key-value对进行排序，实现排序遍历，此时使用key的自然排序和定制排序底层使用红黑树。</p>\n</li>\n<li><p>HashTable</p>\n<p>：作为古老实现类，线程安全，效率低不能存储null的key和value</p>\n<ul>\n<li><strong>Properties</strong>：常用来处理配置文件，key和value都是String类型。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://121.199.69.187/wp-content/uploads/2020/10/Snipaste_2020-10-12_14-55-34-1024x662.png\" alt=\"img\">Map接口结构</p>\n<p><strong>Map的常用方法：</strong></p>\n<p>1.<strong>添加、删除、修改操作：</strong> </p>\n<ol>\n<li>Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 </li>\n<li>void putAll(Map m):将m中的所有key-value对存放到当前map中</li>\n<li>Object remove(Object key)：移除指定key的key-value对，并返回value </li>\n<li>void clear()：清空当前map中的所有数据 </li>\n</ol>\n<p>2.<strong>元素查询的操作：</strong> </p>\n<ol>\n<li>Object get(Object key)：获取指定key对应的value </li>\n<li>boolean containsKey(Object key)：是否包含指定的key</li>\n<li>boolean containsValue(Object value)：是否包含指定的value </li>\n<li>int size()：返回map中key-value对的个数 </li>\n<li>boolean isEmpty()：判断当前map是否为空 </li>\n<li>boolean equals(Object obj)：判断当前map和参数对象obj是否相等</li>\n</ol>\n<p>3.<strong>元视图操作的方法：</strong></p>\n<ol>\n<li>Set keySet()：返回所有key构成的Set集合</li>\n<li>Collection values()：返回所有value构成的Collection集合</li>\n<li>Set entrySet()：返回所有key-value对构成的Set集合</li>\n</ol>\n<h2 id=\"3-Map实现类之一：HashMap\"><a href=\"#3-Map实现类之一：HashMap\" class=\"headerlink\" title=\"3.Map实现类之一：HashMap\"></a>3.Map实现类之一：HashMap</h2><ol>\n<li>HashMap是 Map接口<strong>使用频率最高</strong>的实现类。</li>\n<li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li>\n<li>所有的<strong>key</strong>构成的集合是<strong>Set</strong>:无序的、不可重复的。所以，key所在的类要重写： equals()和hashCode()</li>\n<li>所有的<strong>value</strong>构成的集合是<strong>Collection</strong>:无序的、可以重复的。所以,value所在的类要重写equals()</li>\n<li>一个key-value构成一个entry</li>\n<li>所有的entry构成的集合是Set:无序的、不可重复的</li>\n<li>HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，且hashCode 值也相等。</li>\n<li>HashMap判断两个 key 相等的标准是：两个 value 通过 equals() 方法返回 true。</li>\n</ol>\n<p><img src=\"http://121.199.69.187/wp-content/uploads/2020/10/Snipaste_2020-10-15_19-28-31-1024x647.png\" alt=\"img\"></p>\n<h3 id=\"3-1-HashMap的存储结构与底层实现原理（重点）\"><a href=\"#3-1-HashMap的存储结构与底层实现原理（重点）\" class=\"headerlink\" title=\"3.1 HashMap的存储结构与底层实现原理（重点）\"></a>3.1 HashMap的存储结构与底层实现原理（重点）</h3><p>JDK 7 及以前版本：HashMap是数组+链表结构(即为链地址法) </p>\n<p><img src=\"http://121.199.69.187/wp-content/uploads/2020/10/Snipaste_2020-10-15_20-16-54-1024x546.png\" alt=\"img\"></p>\n<p>JDK 8 版本发布以后：HashMap是<strong>数组+链表+红黑树</strong>实现。</p>\n<p><img src=\"http://121.199.69.187/wp-content/uploads/2020/10/Snipaste_2020-10-15_20-20-21-1024x371.png\" alt=\"img\"></p>\n<p><strong>HashMap的底层实现原理：</strong></p>\n<p>以JDK 7为例，我们先把添加数据的过程简要分析一下：</p>\n<p>先新new一个HashMap：<em>HashMap map = new HashMap( );</em> </p>\n<p>在实例化之后，底层创建了长度是16的一维数组：<em>Entry[ ] table</em></p>\n<p>然后就该向map中添加元素(Entry)了：调用 <em>map.put(key1,value1);</em></p>\n<p>调用key1所在类的*hashCode( )*；计算key1的哈希值，此值经过某种计算后得到在Entry数组中存放的位置</p>\n<p>此位置上是否有元素</p>\n<p>如果此位置上的数据为空，则此时key1-value1添加成功 —-&gt;情况 1</p>\n<p>如果此位置上的数据不为空，意味着此位置上存在一个或多个数据（以链表形式存在），比较key1和已经存在的一个或多个数据的哈希值</p>\n<p>key1的哈希值与已经存在的数据哈希值异同</p>\n<p>如果key1和已有数据哈希值都不相同，则此时key1-value1添加成功。—-&gt;情况2</p>\n<p>如果key1和已有数据的某一个哈希值相同（key2-value2），继续比较，调用key1所在类的*equals(key2-value2)*比较</p>\n<p>equals(key2-value2)比较结果</p>\n<p>如果返回false，key1-value1添加成功 —-&gt; 情况3</p>\n<p>如果返回true，使用value1替换value2。</p>\n<p>补充：关于情况2和情况3，此时key1-value1和原来的数据以链表形式存储；在不断添加的过程中，会涉及到扩容问题，当超出临界值（且要存放的位置非空），默认的扩容方式为原来的容量的两倍，并将原有的数据复制过来。</p>\n<p>jdk8相较于jdk7在底层实现方面的不同：</p>\n<ul>\n<li>new HashMap();底层没有创建一个长度为16的数组 </li>\n<li>jdk8底层的数组是Node类型的数组，而非entry数组 </li>\n<li><strong>首次调用put()时，底层创建长度为16的数组</strong> </li>\n<li>jdk7底层结构只有数组+链表；jdk8中底层结构：<strong>数组+链表+红黑树</strong> </li>\n<li>jdk8使用红黑树的情况：<strong>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时</strong>，此时此索引位置上的所有数据改为使用红黑树存储</li>\n</ul>\n<p><em>如果向更深入了解HashMap的底层知识，请深吸一口气，点开下面的折叠条。</em></p>\n<p>HashMap分析</p>\n<p><strong>HR：谈谈你对HashMap中put/get方法的认识？如果了解再谈谈 HashMap的扩容机制？默认大小是多少？什么是负载因子( 或填充比)？什么是吞吐临界值(或阈值、threshold)？</strong></p>\n<p><strong>HR：负载因子值的大小，对HashMap有什么影响</strong></p>\n<ol>\n<li>负载因子的大小决定了HashMap的数据密度。 </li>\n<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。 </li>\n<li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的 几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建 议初始化预设大一点的空间。 </li>\n<li>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此 时平均检索长度接近于常数。</li>\n</ol>\n<h2 id=\"4-Map的实现类之二：LinkedHashMap\"><a href=\"#4-Map的实现类之二：LinkedHashMap\" class=\"headerlink\" title=\"4.Map的实现类之二：LinkedHashMap\"></a>4.Map的实现类之二：LinkedHashMap</h2><ol>\n<li>LinkedHashMap是HashMap的子类</li>\n<li>再HashMap的存储结构基础上，使用了一对双向链表来记录添加元素的顺序</li>\n<li>与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致</li>\n</ol>\n<p><strong>LinkedHashMap的Entry：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;\n    Entry&lt;K,V&gt; before, after;&#x2F;&#x2F;能够记录添加的元素的先后顺序\n    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n        super(hash, key, value, next);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>HashMap的Node：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;\n   final int hash;\n   final K key;\n   V value;\n   Node&lt;K,V&gt; next;\n &#125;</code></pre>\n\n<h2 id=\"5-Map的实现类之三：TreeMap\"><a href=\"#5-Map的实现类之三：TreeMap\" class=\"headerlink\" title=\"5.Map的实现类之三：TreeMap\"></a>5.Map的实现类之三：TreeMap</h2><ol>\n<li><p>TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。 TreeMap 可以保证所有的 Key-Value 对处于<strong>有序</strong>状态。 </p>\n</li>\n<li><p>TreeSet底层使用<strong>红黑树</strong>结构存储数据 </p>\n</li>\n<li><p>TreeMap 的 Key 的排序：</p>\n<ul>\n<li><strong>自然排序</strong>：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException </li>\n<li><strong>定制排序</strong>：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口 </li>\n</ul>\n</li>\n<li><p>TreeMap判断<strong>两个key相等的标准</strong>：两个key通过compareTo()方法或 者compare()方法返回0。</p>\n</li>\n</ol>\n<ul>\n<li><strong>TreeMap的自然排序：</strong></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void test()  &#123;\n    TreeMap map&#x3D;new TreeMap();\n    Person p1&#x3D;new Person(&quot;tom&quot;,10);\n    Person p2&#x3D;new Person(&quot;jack&quot;,15);\n    Person p3&#x3D;new Person(&quot;jerry&quot;,14);\n    Person p4&#x3D;new Person(&quot;hell&quot;,16);\n    Person p5&#x3D;new Person(&quot;duck&quot;,19);\n    map.put(p1,95);\n    map.put(p2,98);\n    map.put(p3,99);\n    map.put(p4,100);\n    map.put(p5,92);\n \n    Set entrySet&#x3D;map.entrySet();\n    Iterator iterator1 &#x3D; entrySet.iterator();\n    while (iterator1.hasNext())&#123;\n        Object obj &#x3D;iterator1.next();\n        &#x2F;&#x2F;entrySet集合中元素都是entry\n        Map.Entry entry &#x3D;(Map.Entry) obj;\n        System.out.println(entry.getKey()+&quot;----&gt;&quot;+entry.getValue());\n    &#125;\n \n&#125;</code></pre>\n\n<ul>\n<li><strong>TreeMap的定制排序：</strong></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void test1()&#123;\n        TreeMap map&#x3D;new TreeMap(new Comparator() &#123;\n            @Override\n            public int compare(Object o1, Object o2) &#123;\n                if (o1 instanceof Person &amp;&amp; o2 instanceof Person)&#123;\n                    Person p1&#x3D;(Person) o1;\n                    Person p2&#x3D;(Person) o2;\n                    return Integer.compare(p1.getAge(),p2.getAge());\n \n                &#125;\n                throw new RuntimeException(&quot;输入的类型有误&quot;);\n            &#125;\n        &#125;);\n        Person p1&#x3D;new Person(&quot;tom&quot;,10);\n        Person p2&#x3D;new Person(&quot;jack&quot;,15);\n        Person p3&#x3D;new Person(&quot;jerry&quot;,14);\n        Person p4&#x3D;new Person(&quot;hell&quot;,16);\n        Person p5&#x3D;new Person(&quot;duck&quot;,19);\n        map.put(p1,95);\n        map.put(p2,98);\n        map.put(p3,99);\n        map.put(p4,100);\n        map.put(p5,92);\n \n        Set entrySet&#x3D;map.entrySet();\n        Iterator iterator1 &#x3D; entrySet.iterator();\n        while (iterator1.hasNext())&#123;\n            Object obj &#x3D;iterator1.next();\n            &#x2F;&#x2F;entrySet集合中元素都是entry\n            Map.Entry entry &#x3D;(Map.Entry) obj;\n            System.out.println(entry.getKey()+&quot;----&gt;&quot;+entry.getValue());\n        &#125;\n&#125;</code></pre>\n\n<h2 id=\"6-Map实现类之四：Hashtable\"><a href=\"#6-Map实现类之四：Hashtable\" class=\"headerlink\" title=\"6.Map实现类之四：Hashtable\"></a><strong>6.Map实现类之四：Hashtable</strong></h2><ol>\n<li>Hashtable是个古老的 Map 实现类，JDK1.0就提供了。</li>\n<li>不同于HashMap， Hashtable是<strong>线程安全</strong>的。 </li>\n<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用<strong>哈希表</strong>结构，<strong>查询速度快</strong>，很多情况下可以互用。 </li>\n<li>与HashMap不同，Hashtable <strong>不允许使用 null 作为 key 和 value</strong></li>\n<li>与HashMap一样，Hashtable 也<strong>不能保证其中 Key-Value 对的顺序</strong></li>\n<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li>\n</ol>\n<h2 id=\"7-Map实现类之五：Properties\"><a href=\"#7-Map实现类之五：Properties\" class=\"headerlink\" title=\"7.Map实现类之五：Properties\"></a>7.<strong>Map实现类之五：Properties</strong></h2><ul>\n<li>Properties 类是 Hashtable 的子类，该对象用于处理属性文件 </li>\n<li>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型</li>\n<li>存取数据时，建议使用setProperty(String key,String value)方法和 getProperty(String key)方法</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Properties pros &#x3D; new Properties();\n  pros.load(new FileInputStream(&quot;jdbc.properties&quot;));\n  String user &#x3D; pros.getProperty(&quot;user&quot;);\n  System.out.println(user);</code></pre>\n\n<p><strong>关于Properties的练习</strong></p>\n<p>第一步，在IDEA中创建一个名为xxx.properties的文档，这里以jdbc.properties为例</p>\n<p><img src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" alt=\"img\">properties文件</p>\n<p>然后在文档里写入数据，以key-value的形式</p>\n<p><img src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" alt=\"img\"></p>\n<p>其中，name为key；age为value。</p>\n<p>然后创建一个测试类</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package JavaSenior.CollectionTest.Map;\n \nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.PasswordAuthentication;\nimport java.sql.JDBCType;\nimport java.util.Properties;\n \n&#x2F;**\n * @author du guodong\n * @create 2020-10-08-9:22\n *&#x2F;\npublic class PropertiesTest &#123;\n    public static void main(String[] args)  &#123;\n        FileInputStream fis &#x3D; null;\n        try &#123;\n            Properties pros &#x3D; new Properties();\n            fis &#x3D; new FileInputStream(&quot;jdbc.properties&quot;);\n            pros.load(fis);&#x2F;&#x2F;加载流对应的文件\n            String name &#x3D; pros.getProperty(&quot;name&quot;);\n            String age &#x3D; pros.getProperty(&quot;age&quot;);\n \n            System.out.println(name+ &quot;&#x3D;&#x3D;&gt;&quot;+age);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            if (fis!&#x3D;null)&#123;\n                try &#123;\n                    fis.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n \n    &#125;\n \n&#125;\n&#125;</code></pre>\n\n<p>运行测试即可，详细的讲解以后补充。</p>\n","text":"1.Map接口概述： Map与Collection并列存在，用于保存具有映射关系的数据：key-value Map中的key和value都可以是任何引用类型的数据。 Map中的key用Set来存放，不允许重复，即同一个Map对象所对应的类，须重写hashCode()和equlas...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"Java SE","slug":"Java-SE","count":1,"path":"api/categories/Java-SE.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Map%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">1.Map接口概述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2.Map实现类结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%80%EF%BC%9AHashMap\"><span class=\"toc-text\">3.Map实现类之一：HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-HashMap%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">3.1 HashMap的存储结构与底层实现原理（重点）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%BA%8C%EF%BC%9ALinkedHashMap\"><span class=\"toc-text\">4.Map的实现类之二：LinkedHashMap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%89%EF%BC%9ATreeMap\"><span class=\"toc-text\">5.Map的实现类之三：TreeMap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E5%9B%9B%EF%BC%9AHashtable\"><span class=\"toc-text\">6.Map实现类之四：Hashtable</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%BA%94%EF%BC%9AProperties\"><span class=\"toc-text\">7.Map实现类之五：Properties</span></a></li></ol>","author":{"name":"追了又追","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/konghaowen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"MyBatis","uid":"7a897380fbf2b52c7fdc533d413e1985","slug":"MyBatis","date":"2021-05-31T02:39:00.000Z","updated":"2021-09-01T16:27:08.588Z","comments":true,"path":"api/articles/MyBatis.json","keywords":null,"cover":null,"text":"简介MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 作用MyBatis能帮助我们快速开发基于J...","link":"","photos":[],"count_time":{"symbolsCount":209,"symbolsTime":"1 mins."},"categories":[{"name":"后端","slug":"后端","count":1,"path":"api/categories/后端.json"}],"tags":[],"author":{"name":"追了又追","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/konghaowen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}}},"next_post":{"title":"TCP/IP","uid":"663da5c433b044584e25ee70419ef2e6","slug":"TCPIP","date":"2021-05-31T02:39:00.000Z","updated":"2021-08-31T04:01:46.000Z","comments":true,"path":"api/articles/TCPIP.json","keywords":null,"cover":[],"text":"具体含义：1.指代2种协议. TCP和IP协议 2.IP进行通信时所必须用到的协议群的统称。 特点：开放性 注重实用性（被标准化的协议能否被实际运用） 分层模型物理层（硬件层）负责数据传输的硬件 数据链路层（网络接口层）利用以太网中的数据链路层进行通信。 属于接口层。 网络层（互...","link":"","photos":[],"count_time":{"symbolsCount":691,"symbolsTime":"1 mins."},"categories":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/categories/计算机网络.json"}],"tags":[],"author":{"name":"追了又追","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/konghaowen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}}}}