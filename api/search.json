[{"id":"27cb2429407dd68dded9278b4bf7f5c0","title":"关键字：HTML","content":"如果拿盖房子做比喻的话，HTML是用于搭建骨架的，使我们盖的房子有一个大概的样子；CSS是用来装修房子的，让我们的房子变得漂亮，变得五颜六色；JS是用来将我们房子拥有许多功能（实现一些动态效果），他能够提供了许多的动作，比如我们能够做饭、洗澡、洗衣服等等。————–CSDN1.HTMLHTML，中文译为超文本标记语言，是构成网页文档的主要语言，主要用来实现静态页面。一般情况下，用户看到的文字，图形，动画，声音，表格，链接等元素都是由HTML语言描述的。“超”，即超越文本，指可设置样 式、可展示图片，而最核心的是“超级链接”,可以链接到其他文档。由于HTML是由标签组成的，所以使用HTML就是在基本结构上加标签。———\n在这里插入图片描述\n*\n\nform：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围\n属性：\naction：指定提交数据的URL\nmethod:指定提交方式\n分类：一共7种，2种比较常用\nget：\n\n\n请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。\n请求参数大小是有限制的。\n不太安全。\n\n\npost：\n\n\n请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)\n请求参数的大小没有限制。\n较为安全。​\n\n\n表单项中的数据要想被提交：必须指定其name属性\n表单项标签：\ninput：可以通过type属性值，改变元素展示的样式\ntype属性：\ntext：文本输入框，默认值\nplaceholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息\npassword：密码输入框\nradio:单选框\n注意：\n\n\n要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。\n一般会给每一个单选框提供value属性，指定其被选中后提交的值\nchecked属性，可以指定默认值\n\n\ncheckbox：复选框\n注意：\n\n\n一般会给每一个单选框提供value属性，指定其被选中后提交的值\nchecked属性，可以指定默认值​\n\n\nfile：文件选择框\nhidden：隐藏域，用于提交一些信息。\n按钮：\nsubmit：提交按钮。可以提交表单\nbutton：普通按钮\nimage：图片提交按钮\nsrc属性指定图片的路径​\nlabel：指定输入项的文字描述信息\n注意：\nlabel的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。\nselect: 下拉列表\n子元素：option，指定列表项\ntextarea：文本域\ncols：指定列数，每一行有多少个字符\nrows：默认多少行。\n\n超级文本标记语言文档制作不是很复杂，但功能强大，支持不同数据格式的文件镶入，这也是万维网（WWW）盛行的原因之一，其主要特点如下：\n简易性：超级文本标记语言版本升级采用超集方式，从而更加灵活方便。可扩展性：超级文本标记语言的广泛应用带来了加强功能，增加标识符等要求，超级文本标记语言采取子类元素的方式，为系统扩展带来保证。平台无关性：虽然个人计算机大行其道，但使用MAC等其他机器的大有人在，超级文本标记语言可以使用在广泛的平台上，这也是万维网（WWW）盛行的另一个原因。通用性：另外，HTML是网络的通用语言，一种简单、通用的全置标记语言。它允许网页制作人建立文本与图片相结合的复杂页面，这些页面可以被网上任何其他人浏览到，无论使用的是什么类型的电脑或浏览器。\n","slug":"HTML","date":"2021-05-31T02:39:00.000Z","categories_index":"前端","tags_index":"","author_index":"追了又追"},{"id":"f786e96deb9063010a665f3497a78605","title":"关键字：JavaScript","content":"如果拿盖房子做比喻的话，HTML是用于搭建骨架的，使我们盖的房子有一个大概的样子；CSS是用来装修房子的，让我们的房子变得漂亮，变得五颜六色；JS是用来将我们房子拥有许多功能（实现一些动态效果），他能够提供了许多的动作，比如我们能够做饭、洗澡、洗衣服等等。————–CSDN\njavascript主要是为了实现在前端页面显示的一些动态效果.它也是一门非常强大的语言,不仅可以写前端页面,也可以编写后端.可以说非常的强大,语言的兼容性非常的好,不会轻易的报错.——-博客园\n（一）简介（JS）1).JavaScript（JS）是一种网页脚本语言。通过在HTML网页中直接嵌入JS脚本，可以实现响应浏览器事件，读写HTML元素内容，更改HTML元素样式等功能。JS代码可以很容易的嵌入html页面中。也可以单独将JS代码写在一个文件中。浏览器对JS脚本程序进行解释执行。\n基本写法：\njavascript代码块或者短代码\n2).一个完整的 JavaScript 实现是由以下 3 个不同部分组成1.核心（ECMAScript）2.文档对象模型（DOM） Document object model (整合js，css，html)3.浏览器对象模型（BOM） Broswer object model（整合js和浏览器）Javascript 在开发中绝大多数情况是基于对象的.也是面向对象的.（二）JavaScript内置对象（1）window:负责操作浏览器窗口，负责窗口的状态，开/闭等。（2）document：负责操作浏览器载入的文档（html文件），从属于window。（3）history：可以代替后退（前进）按钮访问历史记录，从属于window。（4）location：访问地址栏，也从属于window。\n","slug":"JavaScript","date":"2021-05-31T02:39:00.000Z","categories_index":"前端","tags_index":"","author_index":"追了又追"},{"id":"cd56a15754b2c34473daed46315fe216","title":"关键字：CSS","content":"如果拿盖房子做比喻的话，HTML是用于搭建骨架的，使我们盖的房子有一个大概的样子；CSS是用来装修房子的，让我们的房子变得漂亮，变得五颜六色；JS是用来将我们房子拥有许多功能（实现一些动态效果），他能够提供了许多的动作，比如我们能够做饭、洗澡、洗衣服等等。————–CSDN\n\n概念： Cascading Style Sheets 层叠样式表\n\n\n层叠：多个样式可以作用在同一个html的元素上，同时生效​ 用于控制网页样式\n\n\n好处：\n功能强大\n将内容展示和样式控制分离\n\n\n降低耦合度,解耦\n让分工协作更容易\n提高开发效率\n\n1，内嵌式内嵌式是将CSS代码集中写在HTML文档的头部标签中，并用style标记定义基本语法如下：\n&lt;style type &#x3D; &quot;text&#x2F;css&quot;&gt; \n \n                                            选择器&#123;属性1：属性值2；属性2：属性值2；属性3：属性值3&#125;\n\n2，链入式链入式是将所有的样式放在一个或多个以CSS为拓展名的外部样式表文件中，通过标记将外部样式表文件链接到html文件中\n基本语法如下\n3，CSS选择器和常用属性（1），标记选择器基本语法如下：\n标记名{属性1：属性值1；属性2：属性值2；属性值3：属性值3；}（2），类选择器基本语法如下：\n.类名{属性1：属性值1；属性2：属性值2；属性值3：属性值3；}（3），id选择器基本语法如下：\n#id{属性1：属性值1；属性2：属性值2；属性值3：属性值3；}（4），通配符选择器基本语法如下：\n","slug":"CSS","date":"2021-05-31T02:39:00.000Z","categories_index":"前端","tags_index":"","author_index":"追了又追"},{"id":"9996538c634b4fe0a9727deaea0413da","title":"MAP","content":"1.Map接口概述：\nMap与Collection并列存在，用于保存具有映射关系的数据：key-value\nMap中的key和value都可以是任何引用类型的数据。\nMap中的key用Set来存放，不允许重复，即同一个Map对象所对应的类，须重写hashCode()和equlas() 方法，\n常用String类作为Map的 “键” (key)\nkey和value之间存在单向一对一的关系，即通过指定的key总能找到唯一的、确定的value\nMap接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map接口使用频率最高的实现类\n\n2.Map实现类结构\nMap\n：存储双列数据，存储key-value对的数据，类似函数的概念\n\nHashMap\n：作为Map的主要实现类：线程不安全，效率高，可以存储null的key和value\n\nLinkedHashMap：能保证在遍历map元素时，可以按照添加的顺序进行遍历。实现方法是在原有的HashMap底层结构的基础上添加了一对指针，指向前一个和后一个元素。对于频繁遍历的操作，此类执行效率高于HashMap。\n\n\nTreeMap：（有序）保证按照添加的key-value对进行排序，实现排序遍历，此时使用key的自然排序和定制排序底层使用红黑树。\n\nHashTable\n：作为古老实现类，线程安全，效率低不能存储null的key和value\n\nProperties：常用来处理配置文件，key和value都是String类型。\n\n\n\n\n\nMap接口结构\nMap的常用方法：\n1.添加、删除、修改操作： \n\nObject put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 \nvoid putAll(Map m):将m中的所有key-value对存放到当前map中\nObject remove(Object key)：移除指定key的key-value对，并返回value \nvoid clear()：清空当前map中的所有数据 \n\n2.元素查询的操作： \n\nObject get(Object key)：获取指定key对应的value \nboolean containsKey(Object key)：是否包含指定的key\nboolean containsValue(Object value)：是否包含指定的value \nint size()：返回map中key-value对的个数 \nboolean isEmpty()：判断当前map是否为空 \nboolean equals(Object obj)：判断当前map和参数对象obj是否相等\n\n3.元视图操作的方法：\n\nSet keySet()：返回所有key构成的Set集合\nCollection values()：返回所有value构成的Collection集合\nSet entrySet()：返回所有key-value对构成的Set集合\n\n3.Map实现类之一：HashMap\nHashMap是 Map接口使用频率最高的实现类。\n允许使用null键和null值，与HashSet一样，不保证映射的顺序。\n所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写： equals()和hashCode()\n所有的value构成的集合是Collection:无序的、可以重复的。所以,value所在的类要重写equals()\n一个key-value构成一个entry\n所有的entry构成的集合是Set:无序的、不可重复的\nHashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，且hashCode 值也相等。\nHashMap判断两个 key 相等的标准是：两个 value 通过 equals() 方法返回 true。\n\n\n3.1 HashMap的存储结构与底层实现原理（重点）JDK 7 及以前版本：HashMap是数组+链表结构(即为链地址法) \n\nJDK 8 版本发布以后：HashMap是数组+链表+红黑树实现。\n\nHashMap的底层实现原理：\n以JDK 7为例，我们先把添加数据的过程简要分析一下：\n先新new一个HashMap：HashMap map = new HashMap( ); \n在实例化之后，底层创建了长度是16的一维数组：Entry[ ] table\n然后就该向map中添加元素(Entry)了：调用 map.put(key1,value1);\n调用key1所在类的*hashCode( )*；计算key1的哈希值，此值经过某种计算后得到在Entry数组中存放的位置\n此位置上是否有元素\n如果此位置上的数据为空，则此时key1-value1添加成功 —-&gt;情况 1\n如果此位置上的数据不为空，意味着此位置上存在一个或多个数据（以链表形式存在），比较key1和已经存在的一个或多个数据的哈希值\nkey1的哈希值与已经存在的数据哈希值异同\n如果key1和已有数据哈希值都不相同，则此时key1-value1添加成功。—-&gt;情况2\n如果key1和已有数据的某一个哈希值相同（key2-value2），继续比较，调用key1所在类的*equals(key2-value2)*比较\nequals(key2-value2)比较结果\n如果返回false，key1-value1添加成功 —-&gt; 情况3\n如果返回true，使用value1替换value2。\n补充：关于情况2和情况3，此时key1-value1和原来的数据以链表形式存储；在不断添加的过程中，会涉及到扩容问题，当超出临界值（且要存放的位置非空），默认的扩容方式为原来的容量的两倍，并将原有的数据复制过来。\njdk8相较于jdk7在底层实现方面的不同：\n\nnew HashMap();底层没有创建一个长度为16的数组 \njdk8底层的数组是Node类型的数组，而非entry数组 \n首次调用put()时，底层创建长度为16的数组 \njdk7底层结构只有数组+链表；jdk8中底层结构：数组+链表+红黑树 \njdk8使用红黑树的情况：当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所有数据改为使用红黑树存储\n\n如果向更深入了解HashMap的底层知识，请深吸一口气，点开下面的折叠条。\nHashMap分析\nHR：谈谈你对HashMap中put/get方法的认识？如果了解再谈谈 HashMap的扩容机制？默认大小是多少？什么是负载因子( 或填充比)？什么是吞吐临界值(或阈值、threshold)？\nHR：负载因子值的大小，对HashMap有什么影响\n\n负载因子的大小决定了HashMap的数据密度。 \n负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。 \n负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的 几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建 议初始化预设大一点的空间。 \n按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此 时平均检索长度接近于常数。\n\n4.Map的实现类之二：LinkedHashMap\nLinkedHashMap是HashMap的子类\n再HashMap的存储结构基础上，使用了一对双向链表来记录添加元素的顺序\n与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致\n\nLinkedHashMap的Entry：\nstatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;\n    Entry&lt;K,V&gt; before, after;&#x2F;&#x2F;能够记录添加的元素的先后顺序\n    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n        super(hash, key, value, next);\n    &#125;\n&#125;\n\nHashMap的Node：\nstatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;\n   final int hash;\n   final K key;\n   V value;\n   Node&lt;K,V&gt; next;\n &#125;\n\n5.Map的实现类之三：TreeMap\nTreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。 TreeMap 可以保证所有的 Key-Value 对处于有序状态。 \n\nTreeSet底层使用红黑树结构存储数据 \n\nTreeMap 的 Key 的排序：\n\n自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException \n定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口 \n\n\nTreeMap判断两个key相等的标准：两个key通过compareTo()方法或 者compare()方法返回0。\n\n\n\nTreeMap的自然排序：\n\npublic void test()  &#123;\n    TreeMap map&#x3D;new TreeMap();\n    Person p1&#x3D;new Person(&quot;tom&quot;,10);\n    Person p2&#x3D;new Person(&quot;jack&quot;,15);\n    Person p3&#x3D;new Person(&quot;jerry&quot;,14);\n    Person p4&#x3D;new Person(&quot;hell&quot;,16);\n    Person p5&#x3D;new Person(&quot;duck&quot;,19);\n    map.put(p1,95);\n    map.put(p2,98);\n    map.put(p3,99);\n    map.put(p4,100);\n    map.put(p5,92);\n \n    Set entrySet&#x3D;map.entrySet();\n    Iterator iterator1 &#x3D; entrySet.iterator();\n    while (iterator1.hasNext())&#123;\n        Object obj &#x3D;iterator1.next();\n        &#x2F;&#x2F;entrySet集合中元素都是entry\n        Map.Entry entry &#x3D;(Map.Entry) obj;\n        System.out.println(entry.getKey()+&quot;----&gt;&quot;+entry.getValue());\n    &#125;\n \n&#125;\n\n\nTreeMap的定制排序：\n\npublic void test1()&#123;\n        TreeMap map&#x3D;new TreeMap(new Comparator() &#123;\n            @Override\n            public int compare(Object o1, Object o2) &#123;\n                if (o1 instanceof Person &amp;&amp; o2 instanceof Person)&#123;\n                    Person p1&#x3D;(Person) o1;\n                    Person p2&#x3D;(Person) o2;\n                    return Integer.compare(p1.getAge(),p2.getAge());\n \n                &#125;\n                throw new RuntimeException(&quot;输入的类型有误&quot;);\n            &#125;\n        &#125;);\n        Person p1&#x3D;new Person(&quot;tom&quot;,10);\n        Person p2&#x3D;new Person(&quot;jack&quot;,15);\n        Person p3&#x3D;new Person(&quot;jerry&quot;,14);\n        Person p4&#x3D;new Person(&quot;hell&quot;,16);\n        Person p5&#x3D;new Person(&quot;duck&quot;,19);\n        map.put(p1,95);\n        map.put(p2,98);\n        map.put(p3,99);\n        map.put(p4,100);\n        map.put(p5,92);\n \n        Set entrySet&#x3D;map.entrySet();\n        Iterator iterator1 &#x3D; entrySet.iterator();\n        while (iterator1.hasNext())&#123;\n            Object obj &#x3D;iterator1.next();\n            &#x2F;&#x2F;entrySet集合中元素都是entry\n            Map.Entry entry &#x3D;(Map.Entry) obj;\n            System.out.println(entry.getKey()+&quot;----&gt;&quot;+entry.getValue());\n        &#125;\n&#125;\n\n6.Map实现类之四：Hashtable\nHashtable是个古老的 Map 实现类，JDK1.0就提供了。\n不同于HashMap， Hashtable是线程安全的。 \nHashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。 \n与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value\n与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序\nHashtable判断两个key相等、两个value相等的标准，与HashMap一致。\n\n7.Map实现类之五：Properties\nProperties 类是 Hashtable 的子类，该对象用于处理属性文件 \n由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型\n存取数据时，建议使用setProperty(String key,String value)方法和 getProperty(String key)方法\n\nProperties pros &#x3D; new Properties();\n  pros.load(new FileInputStream(&quot;jdbc.properties&quot;));\n  String user &#x3D; pros.getProperty(&quot;user&quot;);\n  System.out.println(user);\n\n关于Properties的练习\n第一步，在IDEA中创建一个名为xxx.properties的文档，这里以jdbc.properties为例\nproperties文件\n然后在文档里写入数据，以key-value的形式\n\n其中，name为key；age为value。\n然后创建一个测试类\npackage JavaSenior.CollectionTest.Map;\n \nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.PasswordAuthentication;\nimport java.sql.JDBCType;\nimport java.util.Properties;\n \n&#x2F;**\n * @author du guodong\n * @create 2020-10-08-9:22\n *&#x2F;\npublic class PropertiesTest &#123;\n    public static void main(String[] args)  &#123;\n        FileInputStream fis &#x3D; null;\n        try &#123;\n            Properties pros &#x3D; new Properties();\n            fis &#x3D; new FileInputStream(&quot;jdbc.properties&quot;);\n            pros.load(fis);&#x2F;&#x2F;加载流对应的文件\n            String name &#x3D; pros.getProperty(&quot;name&quot;);\n            String age &#x3D; pros.getProperty(&quot;age&quot;);\n \n            System.out.println(name+ &quot;&#x3D;&#x3D;&gt;&quot;+age);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            if (fis!&#x3D;null)&#123;\n                try &#123;\n                    fis.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n \n    &#125;\n \n&#125;\n&#125;\n\n运行测试即可，详细的讲解以后补充。\n","slug":"Map","date":"2021-05-31T02:39:00.000Z","categories_index":"Java SE","tags_index":"","author_index":"追了又追"},{"id":"7a897380fbf2b52c7fdc533d413e1985","title":"MyBatis","content":"简介MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。\n作用MyBatis能帮助我们快速开发基于Java + 数据库的程序，能帮助我们快速映射POJO对象和数据库中的数据 同时支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。\n","slug":"MyBatis","date":"2021-05-31T02:39:00.000Z","categories_index":"后端","tags_index":"","author_index":"追了又追"},{"id":"663da5c433b044584e25ee70419ef2e6","title":"TCP/IP","content":"具体含义：1.指代2种协议. TCP和IP协议 2.IP进行通信时所必须用到的协议群的统称。\n特点：开放性  注重实用性（被标准化的协议能否被实际运用）\n分层模型物理层（硬件层）负责数据传输的硬件\n数据链路层（网络接口层）利用以太网中的数据链路层进行通信。 属于接口层。\n网络层（互联网层）互联网层使用IP协议，它相当于OSI模型中的第三层网络层。\n传输层主要功能让应用程序之间实现通信。\n应用层TCP/IP应用的架构绝大多数属于server/c lient 模型\n\n三次握手第一次握手，客户端发起，客户端要给服务端发起建立连接的请求， 标志位（SYN）为1 表示连接建立，同时随机生成32位初始化序列号（seq）。\n第二次握手，服务端发起，向客户端发生消息，但服务端却不知道消息是否发生成功，所以产生了第三次握手来让服务器知道。\n第三次握手，客户端发起，告诉服务端，我接受到了你的消息。\n流程图如下：\n\n四次挥手第一次：客户端想要断开连接，发送报文标志位的FIN = 1，seq =25368，\n第二次，服务端发送ACK=1 ack=25368+1 确认消息包，知道客户端想和我断开连接，不在给服务端发数据了。 服务端告诉客户端我知道你想与我断开，但是我还没有准备好\n第三次，服务端发送 FIN =1 seq = 10568，服务端告诉客户端我要跟你断开\n第四次：客户端发送确认包，然后与服务端断开连接。\n\n三次握手的目的是为了建立一个保证安全的连接，也是ack位置1的消息，不管client还是server 都可以彼此知道我可以给对方发消息和接受消息 。\n四次握手：下次补充。\n","slug":"TCPIP","date":"2021-05-31T02:39:00.000Z","categories_index":"计算机网络","tags_index":"","author_index":"追了又追"},{"id":"385337453c0362e2e26547a4a0f5d697","title":"关键字：enum","content":"枚举类的属性：1.枚举类不应允许被改动，用private final修饰\n2.使用的时候应该在构造器里赋值\n3.定义带参的构造器，则在列出枚举值时也必须对应的传入参数。\n代码：\n \nclass Season&#123;\n    &#x2F;&#x2F;1.声明Season对象的属性:private final修饰\n    private final String seasonName;\n    private final String seasonDesc;\n \n    &#x2F;&#x2F;2.私有化类的构造器,并给对象属性赋值\n    private Season(String seasonName,String seasonDesc)&#123;\n        this.seasonName &#x3D; seasonName;\n        this.seasonDesc &#x3D; seasonDesc;\n    &#125;\n \n    &#x2F;&#x2F;3.提供当前枚举类的多个对象：public static final的\n    public static final Season SPRING &#x3D; new Season(&quot;春天&quot;,&quot;春暖花开&quot;);\n    public static final Season SUMMER &#x3D; new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;);\n    public static final Season AUTUMN &#x3D; new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;);\n    public static final Season WINTER &#x3D; new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;);\n&#125;\n\nEnum类的方法：1.values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有枚举值。\n2.valueOf(String str):把字符串转成对应的枚举类对象。\n3.toString()：返回当前枚举类对象常量的名称。\n注意：枚举类不可以被clone，如果调用clone会抛出一个CloneNotSupportedException的错误。","slug":"enum","date":"2021-05-31T02:39:00.000Z","categories_index":"","tags_index":"","author_index":"追了又追"},{"id":"34c2acd56bc16b503002a852a65f4137","title":"Java 集合","content":"JSON：一种轻量的数据交换格式。\n集合分为 Collection 和 Map 两种体系1.collection接口：单列数据，定义存取一组对象的方法的集合\nList：元素有序，可以重复的集合\nSet：元素无序，不可以重复的集合\nCollection接口是List，Set，Queue接口的父接口。\n接口的方法：\n\nadd(Object obj); 添加元素\naddAll(Collection coll); 添加一个Collection类型的集合\nint size(); 获取有效元素的个数\nvoid clear(); 清空集合\nboolean isEmpty();是否为空集合\nboolean contains(Object obj); 通过调用元素所在类的equals()方法来判断是否是同一个对象。\nboolean containsAll(Collection c); 调用元素所在类的equals()方法来比较，用两个集合元素依次比较。\nboolean remove(Object obj); 通过元素的equals()方法判断是否是要删除的元素，只会删除找到的第一个元素。\nboolean removeAll(Collection coll); 取当前集合的差集\nboolean retainAll(Collection c); 把交集的结果存在当前集合中，不影响 c\nboolean equals(Object obj); 判断集合是否相等\nObject[] toArray(); 转成对象数组\nhashCode(); 获取集合对象的哈希值\niterator(); 返回迭代器对象，用于集合遍历\n\n2.Map接口：双列数据，保存具有映射关系“key-value对”的集合。\nIterator迭代器接口\n使用 Iterator 接口遍历集合元素\nIterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。\nGOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元 素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。\nCollection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所 有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了 Iterator接口的对象。\nIterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。\n集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。\n在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且 下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。\nIterator和ListIterator的异同点\n一．相同点\n都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。\n二．不同点\n1.使用范围不同，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而ListIterator只能用于List及其子类型。\n2.ListIterator有add方法，可以向List中添加对象，而Iterator不能。\n3.ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator不可以。\n4.ListIterator可以定位当前索引的位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。\n5.都可实现删除操作，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。","slug":"java Collection and Map","date":"2021-05-31T02:39:00.000Z","categories_index":"Java SE","tags_index":"","author_index":"追了又追"},{"id":"39fbe56f95ea6b657e8f83c1879e3a6a","title":"Docker_1","content":"Docker是什么？麻烦的环境部署在软件开发中，最麻烦的事情之一就是环境配置。在正常情况下，如果要保证程序能运行，我们需要设置好操作系统，以及各种库和组件的安装。\n举例来说，要运行一个Python程序，计算机必须要有 Python 引擎，还需要安装好程序的各种依赖，甚至还要配置特定的环境变量。假设你有两个程序都需要部署在同一个服务器上，一个需要软件是基于Python2.0，一个是Python3.0，那么在部署上就很容易造成混乱。因为不同版本的Python模块可能互不兼容，况且不同开发环境上的库也需要额外的配置。如果要部署很多程序，而开发环境和部署环境各不相同的话，可想而知配置得多么麻烦。\n为了更好地将软件从一个环境移植到另一个环境上，必须从根源上解决问题，那么如何在移植软件的时候，将一模一样的原始环境迁移过来呢？\n虚拟机（Virtual Machine）虚拟机是移植环境的一种解决方案。虚拟机本质上也是一个软件，在这个软件中，我们可以运行另一种操作系统。比如我们想要在 MacOS 上运行 Linux 系统，我们就在电脑上安装 Linux 镜像，并使用虚拟机打开此镜像，就能创建出一个镜中镜了。这个方案非常方便，想要新环境，就安装镜像，然后使用虚拟机打开，不想要直接删除。但是这个方案有几个缺点：\n\n占用资源多：虚拟机需要安装整个操作系统，自然会消耗大量内存和硬盘空间。如我们只需要运行1MB的软件，有时候也不得不安装几个G的环境才能运行。\n运行步骤冗余：虚拟机安装的是完整的系统，每次运行程序都需要按部就班，打开系统、登入用户等等之类麻烦的步骤，很不方便。\n运行速度慢：为了运行特定环境中的软件，虚拟机必须先运行系统，而系统占用的资源往往很多（网络，GUI，IO等等），自然也会影响运行速度。\n\nLinux容器（Container）为了解决虚拟机存在的这些缺点，Linux发展出了另一种虚拟化的技术：Linux容器。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，就是在正常进程的外面套用了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层程序的隔离。由于容器是进程级别的，相比虚拟机有更多优势：\n\n占有资源少：容器只占用需要的资源，不占用那些用不到的资源。相比于虚拟机安装完整的操作系统，容器需要消耗的空间自然就少了很多。\n资源利用率高：虚拟机都是独享资源，电脑需要为每个虚拟环境单独分配资源，不仅仅占用空间大，而且资源的利用率很低。而容器之间可以共享资源，最大化资源的利用率。\n运行速度快：容器里面的应用就是底层系统的一个进程，所以启动容器相当于直接运行本机的一个进程，而不是一个完整并臃肿的操作系统，自然就快很多。\n\nDocker是什么？Docker属于Linux容器的一种封装，提供简单易用的容器使用接口，它也是目前最流行的Linux容器解决方案。Docker 将软件代码和其依赖，全打包在一个文件中。运行单个文件，就会生成虚拟容器。在这个虚拟容器中，不管本地的操作系统是如何的不同，此容器都能照常运行。\n简而言之，Docker的接口非常简单，可以帮助用户更好地创建和使用容器，让相同的代码在不同的环境上正常运行。\nDocker的用途Docker目前主要有以下三个用途：\n\n提供一次性的环境：本地测试别人的软件、持续集成的时候提供单元测试和构建的环境。\n提供弹性的云服务：因为Docker容器可以随时启动或关闭，所以非常适合动态规划和缩容。\n组建微服务构架：通过多个容器，服务的部署能更加灵活，帮助实现微服务构架。\n\n运行第一个Docker容器安装DockerDocker是一个开源的商业产品，有两个版本：社群版（Community Edition）和企业本（Enterprise Edition）。企业版中包含了一些收费服务，个人开发者一般用不到。下面我们就来下载并使用社区版。\nDocker CE 的安装可以参看官网网站：https://docs.docker.com/get-docker/，请根据自己操作系统的类型选择相对应的版本。\n安装完成后，运行下面的命令，验证是否安装成功。\n$ docker version\n\n确认 Docker 安装完毕后，我们可以使用以下命令运行 Docker：\n$ sudo service docker start\n\n使用 Mac 的朋友直接打开下载好的 Docker 软件即可。\nimage文件Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的设计蓝图。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。\nimage 是二进制文件，在实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。\n# 列出本机所有的 image 文件\n$ docker image ls\n# 删除特定的 image\n$ docker image rm [imageName]\n\nimage 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。\n为了方便分享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，公开分享自己制作的 image 文件也是可以的。\n官方镜像 Hello World下面，我们通过最简单的 image “hello word”，来感受一下 Docker 的易用性。\n首先我们运行下面的命令，将 image 从仓库抓取到本地：\n$ docker image pull hello-world\n\n抓取成功以后，使用下面的指令，就能在本机看到这个 image 文件了：\n$ docker image ls\n\n运行这个 image：\n$ docker container run hello-world\n\ndocker container run 命令会根据 image 的设定，生成一个正在运行的容器实例。\n注意，docker container run 命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从云端仓库自动抓取。因此，前面的 docker image pull 命令并不是必需的步骤。如果运行成功，你就会在屏幕上读到类似下面的输出：\n$ docker container run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n......\n\n输出这段提示以后，hello world 就会停止运行，容器自动终止。\n有些容器不会自动终止，比如一些容器提供的是服务：像是Ubuntu的image，就可以在命令行体验Ubuntu系统：\n$ docker container run -it ubuntu bash\n\n对于那些不会自动终止的容器，我们可以使用 docker container kill 命令终止。首先我们可以使用 docker container ls 找到你要终止容器的id，然后使用 kill 命令终止容器：\n$ docker contianer ls \n\n$ docker container kill [containerId]\n\n建立自己的容器学会使用官方的 image 文件以后，接下来的问题就是，如何生成自己的 image 文件？这里就需要使用 Dockerfile 文件，Dockerfile 是一个文本文件，用来配置 image 的具体内容。Docker 会根据该文件生成二进制的 image 文件。\n下面我们在本地编辑一个 Python 文件 hello.py，这个文件的功能是使用 Python 打印出一行字符串：\nprint(&#39;Hello World :)&#39;)\n\n然后，我们可以在这个项目的相同路径中，新建一个文本文件 .dockerignore，写入以下内容：\n__pycache__\nenv\n\n这段代码表示，pycache 和 env 这两个路径被排除，不会被打包进入 image 文件。如果你没有路径要排除，这个文件可以不用建。\n然后，在项目的根目录下，新建一个文件文件 Dockerfile，写入下面的内容：\nFROM python3.\nCOPY . &#x2F;app\nWORKDIR &#x2F;app\npython3 main.py\n\n上面的代码一共五行，含义如下：\n# 将 image 文件继承与官方的3.7版本的Python\nFROM python:3.7\n# 将当前目录下的所有文件（除了 .dockerignore 排除的路径），都拷贝进 image 文件的 &#x2F;app 目录。\nCOPY . &#x2F;app \n# 指定接下来的工作路径为 &#x2F;app\nWORKDIR &#x2F;app \n# 在 &#x2F;app 目录下，运行 python 文件\nCMD python3 hello.py \n\n有了 Dockerfile 之后，就可以使用 docker image build 命令创建 image 文件了：\n$ docker image build -t python-app .\nor \n$ docker image build -t python-app:0.0.1 .\n\n这段命令行的意思是，-t 参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默然的标签是latest。最后的那个点表示 Dockerfile 文件使用的路径，上面的例子是当前路径，所以是一个点。\n如果运行成功，就能使用 docker image ls 看到新的image文件了。\n创建好 image 之后，就能使用 docker container run 运行 image，并生成容器了。\n$ docker container run python3-app\nHello World :)\n\n如果一切正常，运行上面的命令后，就会返回输出内容，这就代表运行完成啦。\n祝大家学习快乐！\n","slug":"Docker_1","date":"2021-01-08T11:24:37.000Z","categories_index":"Docker","tags_index":"配置,docker学习","author_index":"追了又追"},{"id":"ed698b80a4ed647896206c94dc889942","title":"KMP算法","content":"KMP简介KMP算法是我们数据结构串中最难也是最重要的算法。难是因为KMP算法的代码很优美简洁干练，但里面包含着非常深的思维。真正理解代码的人可以说对KMP算法的了解已经相当深入了。而且这个算法的不少东西的确不容易讲懂，很多正规的书本把概念一摆出直接劝退无数人。这篇文章将尽量以最详细的方式配图介绍KMP算法及其改进。文章的开始我先对KMP算法的三位创始人Knuth,Morris,Pratt致敬，懂得这个算法的流程后你真的不得不佩服他们的聪明才智。\nKMP解决的问题KMP算法的作用是在一个已知字符串中查找子串的位置,也叫做串的模式匹配。比如主串s=“goodgoogle”,子串t=“google”。现在我们要找到子串t 在主串s 中的位置。大家肯定觉得这还不简单，不就在第五个嘛，一眼就看出来了。当然，在字符串非常少时，“肉眼观察法”不失为一个好方法。但如果要你在一千行文本里找一个单词，我想一般人都会数得崩溃吧。这就让我想起来考试的时候，如果一两道选择题不会。这时候，“肉眼观察法”可能效果不错，但是如果好几道大题不会呢？“肉眼观察法”就丝毫不起效了。所以打铁还需自身硬，我们把这种枯燥的事以一定的算法交给计算机处理。第一种我们容易想到的就是暴力求解法。这种方法也叫朴素的模式匹配：\n简单来说就是：从主串s 和子串t 的第一个字符开始，将两字符串的字符一一比对，如果出现某个字符不匹配，主串回溯到第二个字符，子串回溯到第一个字符再进行一一比对。如果出现某个字符不匹配，主串回溯到第三个字符，子串回溯到第一个字符再进行一一比对…一直到子串字符全部匹配成功。\n下面我们通过图片展示这个过程：竖直线表示相等，闪电线表示不等第一个过程：子串“goo”部分与主串相等，’g’不等，结束比对，进行回溯。\n","slug":"KMP","date":"2021-01-08T11:24:37.000Z","categories_index":"数据结构","tags_index":"数据结构复习,串","author_index":"追了又追"},{"id":"e70f3d17f3101a8ebd078650f09bac1e","title":"测试文档","content":"HELLO","slug":"test","date":"2020-08-15T10:49:36.000Z","categories_index":"标签","tags_index":"标记","author_index":"追了又追"}]