[{"id":"f786e96deb9063010a665f3497a78605","title":"关键字：JavaScript","content":"如果拿盖房子做比喻的话，HTML是用于搭建骨架的，使我们盖的房子有一个大概的样子；CSS是用来装修房子的，让我们的房子变得漂亮，变得五颜六色；JS是用来将我们房子拥有许多功能（实现一些动态效果），他能够提供了许多的动作，比如我们能够做饭、洗澡、洗衣服等等。————–CSDN\njavascript主要是为了实现在前端页面显示的一些动态效果.它也是一门非常强大的语言,不仅可以写前端页面,也可以编写后端.可以说非常的强大,语言的兼容性非常的好,不会轻易的报错.——-博客园\n（一）简介（JS）1).JavaScript（JS）是一种网页脚本语言。通过在HTML网页中直接嵌入JS脚本，可以实现响应浏览器事件，读写HTML元素内容，更改HTML元素样式等功能。JS代码可以很容易的嵌入html页面中。也可以单独将JS代码写在一个文件中。浏览器对JS脚本程序进行解释执行。\n基本写法：\njavascript代码块或者短代码\n2).一个完整的 JavaScript 实现是由以下 3 个不同部分组成1.核心（ECMAScript）2.文档对象模型（DOM） Document object model (整合js，css，html)3.浏览器对象模型（BOM） Broswer object model（整合js和浏览器）Javascript 在开发中绝大多数情况是基于对象的.也是面向对象的.（二）JavaScript内置对象（1）window:负责操作浏览器窗口，负责窗口的状态，开/闭等。（2）document：负责操作浏览器载入的文档（html文件），从属于window。（3）history：可以代替后退（前进）按钮访问历史记录，从属于window。（4）location：访问地址栏，也从属于window。\n","slug":"JavaScript","date":"2021-05-31T02:39:00.000Z","categories_index":"前端","tags_index":"","author_index":"追了又追"},{"id":"27cb2429407dd68dded9278b4bf7f5c0","title":"关键字：HTML","content":"如果拿盖房子做比喻的话，HTML是用于搭建骨架的，使我们盖的房子有一个大概的样子；CSS是用来装修房子的，让我们的房子变得漂亮，变得五颜六色；JS是用来将我们房子拥有许多功能（实现一些动态效果），他能够提供了许多的动作，比如我们能够做饭、洗澡、洗衣服等等。————–CSDN1.HTMLHTML，中文译为超文本标记语言，是构成网页文档的主要语言，主要用来实现静态页面。一般情况下，用户看到的文字，图形，动画，声音，表格，链接等元素都是由HTML语言描述的。“超”，即超越文本，指可设置样 式、可展示图片，而最核心的是“超级链接”,可以链接到其他文档。由于HTML是由标签组成的，所以使用HTML就是在基本结构上加标签。———\n在这里插入图片描述\n*\n\nform：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围\n属性：\naction：指定提交数据的URL\nmethod:指定提交方式\n分类：一共7种，2种比较常用\nget：\n\n\n请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。\n请求参数大小是有限制的。\n不太安全。\n\n\npost：\n\n\n请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)\n请求参数的大小没有限制。\n较为安全。​\n\n\n表单项中的数据要想被提交：必须指定其name属性\n表单项标签：\ninput：可以通过type属性值，改变元素展示的样式\ntype属性：\ntext：文本输入框，默认值\nplaceholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息\npassword：密码输入框\nradio:单选框\n注意：\n\n\n要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。\n一般会给每一个单选框提供value属性，指定其被选中后提交的值\nchecked属性，可以指定默认值\n\n\ncheckbox：复选框\n注意：\n\n\n一般会给每一个单选框提供value属性，指定其被选中后提交的值\nchecked属性，可以指定默认值​\n\n\nfile：文件选择框\nhidden：隐藏域，用于提交一些信息。\n按钮：\nsubmit：提交按钮。可以提交表单\nbutton：普通按钮\nimage：图片提交按钮\nsrc属性指定图片的路径​\nlabel：指定输入项的文字描述信息\n注意：\nlabel的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。\nselect: 下拉列表\n子元素：option，指定列表项\ntextarea：文本域\ncols：指定列数，每一行有多少个字符\nrows：默认多少行。\n\n超级文本标记语言文档制作不是很复杂，但功能强大，支持不同数据格式的文件镶入，这也是万维网（WWW）盛行的原因之一，其主要特点如下：\n简易性：超级文本标记语言版本升级采用超集方式，从而更加灵活方便。可扩展性：超级文本标记语言的广泛应用带来了加强功能，增加标识符等要求，超级文本标记语言采取子类元素的方式，为系统扩展带来保证。平台无关性：虽然个人计算机大行其道，但使用MAC等其他机器的大有人在，超级文本标记语言可以使用在广泛的平台上，这也是万维网（WWW）盛行的另一个原因。通用性：另外，HTML是网络的通用语言，一种简单、通用的全置标记语言。它允许网页制作人建立文本与图片相结合的复杂页面，这些页面可以被网上任何其他人浏览到，无论使用的是什么类型的电脑或浏览器。\n","slug":"HTML","date":"2021-05-31T02:39:00.000Z","categories_index":"前端","tags_index":"","author_index":"追了又追"},{"id":"cd56a15754b2c34473daed46315fe216","title":"关键字：CSS","content":"如果拿盖房子做比喻的话，HTML是用于搭建骨架的，使我们盖的房子有一个大概的样子；CSS是用来装修房子的，让我们的房子变得漂亮，变得五颜六色；JS是用来将我们房子拥有许多功能（实现一些动态效果），他能够提供了许多的动作，比如我们能够做饭、洗澡、洗衣服等等。————–CSDN\n\n概念： Cascading Style Sheets 层叠样式表\n\n\n层叠：多个样式可以作用在同一个html的元素上，同时生效​ 用于控制网页样式\n\n\n好处：\n功能强大\n将内容展示和样式控制分离\n\n\n降低耦合度,解耦\n让分工协作更容易\n提高开发效率\n\n1，内嵌式内嵌式是将CSS代码集中写在HTML文档的头部标签中，并用style标记定义基本语法如下：\n&lt;style type &#x3D; &quot;text&#x2F;css&quot;&gt; \n \n                                            选择器&#123;属性1：属性值2；属性2：属性值2；属性3：属性值3&#125;\n\n2，链入式链入式是将所有的样式放在一个或多个以CSS为拓展名的外部样式表文件中，通过标记将外部样式表文件链接到html文件中\n基本语法如下\n3，CSS选择器和常用属性（1），标记选择器基本语法如下：\n标记名{属性1：属性值1；属性2：属性值2；属性值3：属性值3；}（2），类选择器基本语法如下：\n.类名{属性1：属性值1；属性2：属性值2；属性值3：属性值3；}（3），id选择器基本语法如下：\n#id{属性1：属性值1；属性2：属性值2；属性值3：属性值3；}（4），通配符选择器基本语法如下：\n","slug":"CSS","date":"2021-05-31T02:39:00.000Z","categories_index":"前端","tags_index":"","author_index":"追了又追"},{"id":"9996538c634b4fe0a9727deaea0413da","title":"MAP","content":"1.Map接口概述：\nMap与Collection并列存在，用于保存具有映射关系的数据：key-value\nMap中的key和value都可以是任何引用类型的数据。\nMap中的key用Set来存放，不允许重复，即同一个Map对象所对应的类，须重写hashCode()和equlas() 方法，\n常用String类作为Map的 “键” (key)\nkey和value之间存在单向一对一的关系，即通过指定的key总能找到唯一的、确定的value\nMap接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map接口使用频率最高的实现类\n\n2.Map实现类结构\nMap\n：存储双列数据，存储key-value对的数据，类似函数的概念\n\nHashMap\n：作为Map的主要实现类：线程不安全，效率高，可以存储null的key和value\n\nLinkedHashMap：能保证在遍历map元素时，可以按照添加的顺序进行遍历。实现方法是在原有的HashMap底层结构的基础上添加了一对指针，指向前一个和后一个元素。对于频繁遍历的操作，此类执行效率高于HashMap。\n\n\nTreeMap：（有序）保证按照添加的key-value对进行排序，实现排序遍历，此时使用key的自然排序和定制排序底层使用红黑树。\n\nHashTable\n：作为古老实现类，线程安全，效率低不能存储null的key和value\n\nProperties：常用来处理配置文件，key和value都是String类型。\n\n\n\n\n\nMap接口结构\nMap的常用方法：\n1.添加、删除、修改操作： \n\nObject put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 \nvoid putAll(Map m):将m中的所有key-value对存放到当前map中\nObject remove(Object key)：移除指定key的key-value对，并返回value \nvoid clear()：清空当前map中的所有数据 \n\n2.元素查询的操作： \n\nObject get(Object key)：获取指定key对应的value \nboolean containsKey(Object key)：是否包含指定的key\nboolean containsValue(Object value)：是否包含指定的value \nint size()：返回map中key-value对的个数 \nboolean isEmpty()：判断当前map是否为空 \nboolean equals(Object obj)：判断当前map和参数对象obj是否相等\n\n3.元视图操作的方法：\n\nSet keySet()：返回所有key构成的Set集合\nCollection values()：返回所有value构成的Collection集合\nSet entrySet()：返回所有key-value对构成的Set集合\n\n3.Map实现类之一：HashMap\nHashMap是 Map接口使用频率最高的实现类。\n允许使用null键和null值，与HashSet一样，不保证映射的顺序。\n所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写： equals()和hashCode()\n所有的value构成的集合是Collection:无序的、可以重复的。所以,value所在的类要重写equals()\n一个key-value构成一个entry\n所有的entry构成的集合是Set:无序的、不可重复的\nHashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，且hashCode 值也相等。\nHashMap判断两个 key 相等的标准是：两个 value 通过 equals() 方法返回 true。\n\n\n3.1 HashMap的存储结构与底层实现原理（重点）JDK 7 及以前版本：HashMap是数组+链表结构(即为链地址法) \n\nJDK 8 版本发布以后：HashMap是数组+链表+红黑树实现。\n\nHashMap的底层实现原理：\n以JDK 7为例，我们先把添加数据的过程简要分析一下：\n先新new一个HashMap：HashMap map = new HashMap( ); \n在实例化之后，底层创建了长度是16的一维数组：Entry[ ] table\n然后就该向map中添加元素(Entry)了：调用 map.put(key1,value1);\n调用key1所在类的*hashCode( )*；计算key1的哈希值，此值经过某种计算后得到在Entry数组中存放的位置\n此位置上是否有元素\n如果此位置上的数据为空，则此时key1-value1添加成功 —-&gt;情况 1\n如果此位置上的数据不为空，意味着此位置上存在一个或多个数据（以链表形式存在），比较key1和已经存在的一个或多个数据的哈希值\nkey1的哈希值与已经存在的数据哈希值异同\n如果key1和已有数据哈希值都不相同，则此时key1-value1添加成功。—-&gt;情况2\n如果key1和已有数据的某一个哈希值相同（key2-value2），继续比较，调用key1所在类的*equals(key2-value2)*比较\nequals(key2-value2)比较结果\n如果返回false，key1-value1添加成功 —-&gt; 情况3\n如果返回true，使用value1替换value2。\n补充：关于情况2和情况3，此时key1-value1和原来的数据以链表形式存储；在不断添加的过程中，会涉及到扩容问题，当超出临界值（且要存放的位置非空），默认的扩容方式为原来的容量的两倍，并将原有的数据复制过来。\njdk8相较于jdk7在底层实现方面的不同：\n\nnew HashMap();底层没有创建一个长度为16的数组 \njdk8底层的数组是Node类型的数组，而非entry数组 \n首次调用put()时，底层创建长度为16的数组 \njdk7底层结构只有数组+链表；jdk8中底层结构：数组+链表+红黑树 \njdk8使用红黑树的情况：当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所有数据改为使用红黑树存储\n\n如果向更深入了解HashMap的底层知识，请深吸一口气，点开下面的折叠条。\nHashMap分析\nHR：谈谈你对HashMap中put/get方法的认识？如果了解再谈谈 HashMap的扩容机制？默认大小是多少？什么是负载因子( 或填充比)？什么是吞吐临界值(或阈值、threshold)？\nHR：负载因子值的大小，对HashMap有什么影响\n\n负载因子的大小决定了HashMap的数据密度。 \n负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。 \n负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的 几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建 议初始化预设大一点的空间。 \n按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此 时平均检索长度接近于常数。\n\n4.Map的实现类之二：LinkedHashMap\nLinkedHashMap是HashMap的子类\n再HashMap的存储结构基础上，使用了一对双向链表来记录添加元素的顺序\n与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致\n\nLinkedHashMap的Entry：\nstatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;\n    Entry&lt;K,V&gt; before, after;&#x2F;&#x2F;能够记录添加的元素的先后顺序\n    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n        super(hash, key, value, next);\n    &#125;\n&#125;\n\nHashMap的Node：\nstatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;\n   final int hash;\n   final K key;\n   V value;\n   Node&lt;K,V&gt; next;\n &#125;\n\n5.Map的实现类之三：TreeMap\nTreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。 TreeMap 可以保证所有的 Key-Value 对处于有序状态。 \n\nTreeSet底层使用红黑树结构存储数据 \n\nTreeMap 的 Key 的排序：\n\n自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException \n定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口 \n\n\nTreeMap判断两个key相等的标准：两个key通过compareTo()方法或 者compare()方法返回0。\n\n\n\nTreeMap的自然排序：\n\npublic void test()  &#123;\n    TreeMap map&#x3D;new TreeMap();\n    Person p1&#x3D;new Person(&quot;tom&quot;,10);\n    Person p2&#x3D;new Person(&quot;jack&quot;,15);\n    Person p3&#x3D;new Person(&quot;jerry&quot;,14);\n    Person p4&#x3D;new Person(&quot;hell&quot;,16);\n    Person p5&#x3D;new Person(&quot;duck&quot;,19);\n    map.put(p1,95);\n    map.put(p2,98);\n    map.put(p3,99);\n    map.put(p4,100);\n    map.put(p5,92);\n \n    Set entrySet&#x3D;map.entrySet();\n    Iterator iterator1 &#x3D; entrySet.iterator();\n    while (iterator1.hasNext())&#123;\n        Object obj &#x3D;iterator1.next();\n        &#x2F;&#x2F;entrySet集合中元素都是entry\n        Map.Entry entry &#x3D;(Map.Entry) obj;\n        System.out.println(entry.getKey()+&quot;----&gt;&quot;+entry.getValue());\n    &#125;\n \n&#125;\n\n\nTreeMap的定制排序：\n\npublic void test1()&#123;\n        TreeMap map&#x3D;new TreeMap(new Comparator() &#123;\n            @Override\n            public int compare(Object o1, Object o2) &#123;\n                if (o1 instanceof Person &amp;&amp; o2 instanceof Person)&#123;\n                    Person p1&#x3D;(Person) o1;\n                    Person p2&#x3D;(Person) o2;\n                    return Integer.compare(p1.getAge(),p2.getAge());\n \n                &#125;\n                throw new RuntimeException(&quot;输入的类型有误&quot;);\n            &#125;\n        &#125;);\n        Person p1&#x3D;new Person(&quot;tom&quot;,10);\n        Person p2&#x3D;new Person(&quot;jack&quot;,15);\n        Person p3&#x3D;new Person(&quot;jerry&quot;,14);\n        Person p4&#x3D;new Person(&quot;hell&quot;,16);\n        Person p5&#x3D;new Person(&quot;duck&quot;,19);\n        map.put(p1,95);\n        map.put(p2,98);\n        map.put(p3,99);\n        map.put(p4,100);\n        map.put(p5,92);\n \n        Set entrySet&#x3D;map.entrySet();\n        Iterator iterator1 &#x3D; entrySet.iterator();\n        while (iterator1.hasNext())&#123;\n            Object obj &#x3D;iterator1.next();\n            &#x2F;&#x2F;entrySet集合中元素都是entry\n            Map.Entry entry &#x3D;(Map.Entry) obj;\n            System.out.println(entry.getKey()+&quot;----&gt;&quot;+entry.getValue());\n        &#125;\n&#125;\n\n6.Map实现类之四：Hashtable\nHashtable是个古老的 Map 实现类，JDK1.0就提供了。\n不同于HashMap， Hashtable是线程安全的。 \nHashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。 \n与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value\n与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序\nHashtable判断两个key相等、两个value相等的标准，与HashMap一致。\n\n7.Map实现类之五：Properties\nProperties 类是 Hashtable 的子类，该对象用于处理属性文件 \n由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型\n存取数据时，建议使用setProperty(String key,String value)方法和 getProperty(String key)方法\n\nProperties pros &#x3D; new Properties();\n  pros.load(new FileInputStream(&quot;jdbc.properties&quot;));\n  String user &#x3D; pros.getProperty(&quot;user&quot;);\n  System.out.println(user);\n\n关于Properties的练习\n第一步，在IDEA中创建一个名为xxx.properties的文档，这里以jdbc.properties为例\nproperties文件\n然后在文档里写入数据，以key-value的形式\n\n其中，name为key；age为value。\n然后创建一个测试类\npackage JavaSenior.CollectionTest.Map;\n \nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.PasswordAuthentication;\nimport java.sql.JDBCType;\nimport java.util.Properties;\n \n&#x2F;**\n * @author du guodong\n * @create 2020-10-08-9:22\n *&#x2F;\npublic class PropertiesTest &#123;\n    public static void main(String[] args)  &#123;\n        FileInputStream fis &#x3D; null;\n        try &#123;\n            Properties pros &#x3D; new Properties();\n            fis &#x3D; new FileInputStream(&quot;jdbc.properties&quot;);\n            pros.load(fis);&#x2F;&#x2F;加载流对应的文件\n            String name &#x3D; pros.getProperty(&quot;name&quot;);\n            String age &#x3D; pros.getProperty(&quot;age&quot;);\n \n            System.out.println(name+ &quot;&#x3D;&#x3D;&gt;&quot;+age);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            if (fis!&#x3D;null)&#123;\n                try &#123;\n                    fis.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n \n    &#125;\n \n&#125;\n&#125;\n\n运行测试即可，详细的讲解以后补充。\n","slug":"Map","date":"2021-05-31T02:39:00.000Z","categories_index":"Java SE","tags_index":"","author_index":"追了又追"},{"id":"d9b68702cbb0e3caa1a36b35238653ca","title":"PYCHON知识总结","content":"1.概述：    python的特点 \n2.python关键字\n3.python数据类型  整型 浮点型 字符型。\n\npython运算符 算法 关系 逻辑 优先级\npython的程序结构  顺序结构 循环结构 字符串的操作：print 切片 \n列表 字典  集合 元类型 及操作\n函数 def ……    递归调用 \n文件的操作  打开（相对路径 绝对路径）。\n第三方库   pip install 库名称\n异常 try——了解即可\n面向对象编程   声明一个类（成员函数 成员变量）\n成员的可变性如何实现   公有 私有 – 保护 - 系统的 __ xxx__ \n类的构造方法  __ init __():\n类的继承   class（A）.   \n\n1个作业  2个   3个是类\n","slug":"PYCHON知识总结","date":"2021-05-31T02:39:00.000Z","categories_index":"校内复习资料","tags_index":"","author_index":"追了又追"},{"id":"663da5c433b044584e25ee70419ef2e6","title":"TCP/IP","content":"具体含义：1.指代2种协议. TCP和IP协议 2.IP进行通信时所必须用到的协议群的统称。\n特点：开放性  注重实用性（被标准化的协议能否被实际运用）\n分层模型物理层（硬件层）负责数据传输的硬件\n数据链路层（网络接口层）利用以太网中的数据链路层进行通信。 属于接口层。\n网络层（互联网层）互联网层使用IP协议，它相当于OSI模型中的第三层网络层。\n传输层主要功能让应用程序之间实现通信。\n应用层TCP/IP应用的架构绝大多数属于server/c lient 模型\n\n三次握手第一次握手，客户端发起，客户端要给服务端发起建立连接的请求， 标志位（SYN）为1 表示连接建立，同时随机生成32位初始化序列号（seq）。\n第二次握手，服务端发起，向客户端发生消息，但服务端却不知道消息是否发生成功，所以产生了第三次握手来让服务器知道。\n第三次握手，客户端发起，告诉服务端，我接受到了你的消息。\n流程图如下：\n\n四次挥手第一次：客户端想要断开连接，发送报文标志位的FIN = 1，seq =25368，\n第二次，服务端发送ACK=1 ack=25368+1 确认消息包，知道客户端想和我断开连接，不在给服务端发数据了。 服务端告诉客户端我知道你想与我断开，但是我还没有准备好\n第三次，服务端发送 FIN =1 seq = 10568，服务端告诉客户端我要跟你断开\n第四次：客户端发送确认包，然后与服务端断开连接。\n\n三次握手的目的是为了建立一个保证安全的连接，也是ack位置1的消息，不管client还是server 都可以彼此知道我可以给对方发消息和接受消息 。\n四次握手：下次补充。\n","slug":"TCPIP","date":"2021-05-31T02:39:00.000Z","categories_index":"计算机网络","tags_index":"","author_index":"追了又追"},{"id":"7a897380fbf2b52c7fdc533d413e1985","title":"MyBatis","content":"简介MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。\n作用MyBatis能帮助我们快速开发基于Java + 数据库的程序，能帮助我们快速映射POJO对象和数据库中的数据 同时支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。\n","slug":"MyBatis","date":"2021-05-31T02:39:00.000Z","categories_index":"后端","tags_index":"","author_index":"追了又追"},{"id":"385337453c0362e2e26547a4a0f5d697","title":"关键字：enum","content":"枚举类的属性：1.枚举类不应允许被改动，用private final修饰\n2.使用的时候应该在构造器里赋值\n3.定义带参的构造器，则在列出枚举值时也必须对应的传入参数。\n代码：\n \nclass Season&#123;\n    &#x2F;&#x2F;1.声明Season对象的属性:private final修饰\n    private final String seasonName;\n    private final String seasonDesc;\n \n    &#x2F;&#x2F;2.私有化类的构造器,并给对象属性赋值\n    private Season(String seasonName,String seasonDesc)&#123;\n        this.seasonName &#x3D; seasonName;\n        this.seasonDesc &#x3D; seasonDesc;\n    &#125;\n \n    &#x2F;&#x2F;3.提供当前枚举类的多个对象：public static final的\n    public static final Season SPRING &#x3D; new Season(&quot;春天&quot;,&quot;春暖花开&quot;);\n    public static final Season SUMMER &#x3D; new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;);\n    public static final Season AUTUMN &#x3D; new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;);\n    public static final Season WINTER &#x3D; new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;);\n&#125;\n\nEnum类的方法：1.values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有枚举值。\n2.valueOf(String str):把字符串转成对应的枚举类对象。\n3.toString()：返回当前枚举类对象常量的名称。\n注意：枚举类不可以被clone，如果调用clone会抛出一个CloneNotSupportedException的错误。","slug":"enum","date":"2021-05-31T02:39:00.000Z","categories_index":"","tags_index":"","author_index":"追了又追"},{"id":"ed698b80a4ed647896206c94dc889942","title":"KMP算法","content":"KMP简介KMP算法是我们数据结构串中最难也是最重要的算法。难是因为KMP算法的代码很优美简洁干练，但里面包含着非常深的思维。真正理解代码的人可以说对KMP算法的了解已经相当深入了。而且这个算法的不少东西的确不容易讲懂，很多正规的书本把概念一摆出直接劝退无数人。这篇文章将尽量以最详细的方式配图介绍KMP算法及其改进。文章的开始我先对KMP算法的三位创始人Knuth,Morris,Pratt致敬，懂得这个算法的流程后你真的不得不佩服他们的聪明才智。\nKMP解决的问题KMP算法的作用是在一个已知字符串中查找子串的位置,也叫做串的模式匹配。比如主串s=“goodgoogle”,子串t=“google”。现在我们要找到子串t 在主串s 中的位置。大家肯定觉得这还不简单，不就在第五个嘛，一眼就看出来了。当然，在字符串非常少时，“肉眼观察法”不失为一个好方法。但如果要你在一千行文本里找一个单词，我想一般人都会数得崩溃吧。这就让我想起来考试的时候，如果一两道选择题不会。这时候，“肉眼观察法”可能效果不错，但是如果好几道大题不会呢？“肉眼观察法”就丝毫不起效了。所以打铁还需自身硬，我们把这种枯燥的事以一定的算法交给计算机处理。第一种我们容易想到的就是暴力求解法。这种方法也叫朴素的模式匹配：\n简单来说就是：从主串s 和子串t 的第一个字符开始，将两字符串的字符一一比对，如果出现某个字符不匹配，主串回溯到第二个字符，子串回溯到第一个字符再进行一一比对。如果出现某个字符不匹配，主串回溯到第三个字符，子串回溯到第一个字符再进行一一比对…一直到子串字符全部匹配成功。\n下面我们通过图片展示这个过程：竖直线表示相等，闪电线表示不等第一个过程：子串“goo”部分与主串相等，’g’不等，结束比对，进行回溯。\n","slug":"KMP","date":"2021-01-08T11:24:37.000Z","categories_index":"数据结构","tags_index":"数据结构复习,串","author_index":"追了又追"},{"id":"e70f3d17f3101a8ebd078650f09bac1e","title":"测试文档","content":"HELLO","slug":"test","date":"2020-08-15T10:49:36.000Z","categories_index":"标签","tags_index":"标记","author_index":"追了又追"}]